## 2026 백엔드 취업 준비 로드맵 (통합본)

> 목표: **서비스 1개를 ‘개발 → 배포 → 운영 → 개선’까지 완주**하고, 그 과정을 **문서 + 수치**로 증명한다.
> 원칙: 많이 하기보다 **끝까지 완성**하고, **기록/지표로 설명 가능**하게 만든다.

---

## 1) 최종 산출물(취업용 패키지)

### 1-1. 메인 백엔드 서비스 1개(필수)
- REST API + DB(MySQL) + 인증/인가(세션/JWT/OAuth 중 1)
- 예외/검증/표준 에러 응답
- 배포 완료(도메인/HTTPS/Nginx Reverse Proxy)
- 운영 흔적(로그/모니터링/알림 중 최소 1개)

### 1-2. 개선 이력(필수)
- 성능 개선 1~2개를 **전/후 수치**로 남기기(쿼리 튜닝, 캐시, 구조 개선 등)
- 부하테스트로 **Latency / Throughput / Error Rate** 기록

### 1-3. 문서 세트(필수)
- README: **문제 → 행동 → 결과**
- ERD + 설계 근거(정규화/관계/인덱스)
- API 명세 + 에러 응답 표준 + 주요 시나리오
- 배포/운영 문서 + 트러블슈팅 로그(문제→시도→결과)

### 1-4. 차별화 확장 1개(선택)
- Kubernetes / Kafka / Elasticsearch / MSA 중 **1개만** 선택
- “적용 + 근거 + 트레이드오프”까지 설명 가능하도록 설계/문서화

---

## 2) 백엔드가 책임지는 핵심 영역(학습 범위 기준선)

- **API**: REST 설계, 상태코드/에러 포맷, 문서화(OpenAPI)
- **데이터**: 스키마/관계/인덱스, 트랜잭션, 마이그레이션, 백업/복구
- **인증/인가**: 로그인, 권한(RBAC), 세션/JWT/OAuth
- **성능**: 쿼리 튜닝, 캐시(Redis), 병목 제거, 부하테스트
- **안정성**: 재시도/타임아웃, 레이트리밋, 장애 대응/롤백
- **운영**: 배포, 로깅/모니터링, 알림, HTTPS/보안 기본

---

## 3) 전체 학습 지도(0 → 1 → 10 → 100)

### 0단계: 기초 체력(필수)
- HTTP/HTTPS, DNS, 쿠키/세션, CORS
- Linux(프로세스/포트/로그/권한)
- Git(GitHub 기반 협업 플로우: 브랜치/PR/리뷰)

### 1단계: 언어 1개 + 프레임워크 1개(필수)
- Java + Spring Boot(권장) 또는 JS/TS + Nest/Express
- **한 개를 깊게**: API 설계/구현을 혼자 완주할 수 있는 수준

### 10단계: 취업권(프로젝트 완성 레벨)
- DB 설계 + ORM(JPA) + SQL 이해
- 인증/인가 + 기본 보안(비밀번호 해시, 토큰/세션)
- 테스트(단위/통합) + 문서(OpenAPI)
- 배포/운영(Nginx/HTTPS/환경분리) + Docker/CI/CD(최소)

### 100단계: 실무 성장(확장/운영/설계)
- 캐시(Redis), 메시징(Kafka), 검색(Elasticsearch), 비동기 워커
- 관측성(로그/메트릭/트레이싱), 알림, SLO/SLI
- 시스템 설계/장애 대응/비용 최적화

---

## 4) 실행 로드맵(순서) — 결과물 중심

### Phase A. 백엔드 기본기: “DB 없이도 API를 제대로 만든다”
**학습/구현**
- REST 설계(리소스/상태코드/에러 포맷)
- 레이어링(Controller-Service-Repository), DTO 분리
- Validation + Global Exception 처리
- OpenAPI(Swagger) 문서 자동화

**산출물**
- 작은 도메인 CRUD API + 에러 표준 문서 + OpenAPI

---

### Phase B. DB 설계 + JPA 연동: “서비스 형태로 완성”
**학습/구현**
- 요구사항 → 엔티티 도출 → 관계/정규화 → ERD
- JPA 핵심(연관관계, 트랜잭션, fetch 전략)
- 조회 조건 기반 인덱스 설계(최소)
- 스키마 마이그레이션(Flyway/Liquibase 중 1)

**산출물**
- ERD 이미지 + 설계 근거 문서
- DB 연동된 핵심 기능 API 완성

---

### Phase C. 인증/인가 & 보안 베이스라인: “취업용 CRUD 완성”
**학습/구현**
- 비밀번호 해시(BCrypt/Argon2 중 1)
- 세션/JWT(만료/리프레시/회수 전략 중 최소 1)
- 권한 모델(RBAC) + 보호가 필요한 API 정리
- 입력 검증/기본 공격 방어(로그인/인증 API 보호)

**산출물**
- 로그인/권한 적용 + 보안 체크리스트 문서

---

### Phase D. 배포/운영 최소 구성: “실사용 URL + 운영 루틴”
**학습/구현**
- Linux 운영 루틴(로그/프로세스/포트/디스크)
- Nginx Reverse Proxy + HTTPS
- 환경 분리(dev/prod) + 시크릿 관리(최소)
- 장애 시 확인 순서(체크리스트) + 간단한 롤백 전략

**산출물**
- 도메인/HTTPS로 접근 가능한 서비스 URL
- 배포 문서 + 운영 체크리스트(장애 대응 포함)

---

### Phase E. 코드 품질: “테스트와 리팩토링으로 신뢰도 확보”
**학습/구현**
- 단위 테스트(서비스 로직), 통합 테스트(API/DB)
- 리팩토링(책임 분리, 중복 제거, 규칙 표현)
- 변경에 강한 구조(의존성 분리, Mock/Stub)

**산출물**
- 핵심 규칙을 보호하는 테스트 세트
- 리팩토링 전/후 기록(PR/커밋) + 테스트 전략 문서

---

### Phase F. 성능/확장: “개선을 숫자로 증명”
**학습/구현**
- MySQL 실행계획 기반 쿼리/인덱스 튜닝
- Redis 캐시(키/TTL/무효화 전략 포함)
- 부하테스트로 전/후 비교(Throughput/Latency/Error Rate)

**산출물**
- 성능 개선 리포트(문제→가설→변경→측정→결과)
- 부하테스트 스크립트 + 결과 캡처/요약

---

## 5) 차별화 확장(1개만 선택)

### 옵션 A) Elasticsearch (FlowMate에 특히 적합)
- 글로벌 검색(투두/세션/태그 통합), 자동완성/오타 허용/가중치/필터/정렬
- 동기화 전략(예: Outbox → 비동기 인덱싱, 실패 재시도)
- 장애 시 degrade/fallback 전략 문서화

### 옵션 B) Kafka
- 이벤트 발행/구독 + 재처리/중복/순서 이슈 대응 전략

### 옵션 C) Kubernetes
- Ingress/Service/Deployment/Config/Secret 기반 배포 + 롤링/장애 대응 기록

### 옵션 D) MSA
- 최소 2서비스 분리 + “왜 분리했는지”와 운영 트레이드오프 문서화

---

## 6) 코딩 테스트 루틴(최소 유지)
- 매일 30분(끊기지 않는 게 핵심)
- 새 문제 + 복습(실수 유형 기록)
- 목표: 속도보다 **패턴 축적/재현 가능성**

---

## 7) CS 학습 범위(면접용 핵심만)
- 네트워크: HTTP/TLS, 쿠키·세션·JWT, LB/프록시
- DB: 트랜잭션/격리수준, 인덱스, 락, 실행계획
- OS: 프로세스/스레드, 메모리, 컨텍스트 스위칭
- 자료구조/알고리즘: 빈출 패턴 중심

---

## 8) 합격 체크포인트(게이트)
- 배포된 서비스가 있고, 누구나 호출 가능하다
- ERD/정규화/인덱스 설계를 설명할 수 있다
- 테스트가 핵심 규칙을 보호한다(왜 필요한지 말 가능)
- 성능 개선을 전/후 수치로 말할 수 있다
- 트러블슈팅과 운영 경험이 문서로 남아 있다

---