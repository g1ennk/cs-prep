# String 객체는 가변일가요, 불변일까요? 그렇게 생각하신 이유도 함께 설명해 주세요

## 요약

- String 객체는 불변으로 내부적으로 final 키워드가 선언된 byte[] 필드를 사용해 문자열을 저장한다.
- 또한 String은 참조 타입이기 때문에 `concat(), replace()`와 같은 메서드 실행 시 새로운 String 객체를 만들어서 재정의하여 불변을 유지한다.

### String을 불변으로 설계한 이유는?

- 메모리 효율성: String Pool로 동일한 리터럴(문자열)을 하나의 객체로 공유하여, 중복 생성이 감소하고 메모리를 절감한다.
- 스레드 안정성: 값이 변하지 않기 때문에 읽기 공유가 본질적으로 Thread-Safe하여, 동기화 비용이 없다.
- 해시 성능: hashCode()를 한 번 계산 후 캐싱하여 성능이 좋다.
- 보안: 비밀번호, 토큰, URL 등의 민감한 정보를 안전하게 다룰 수 있다. 왜? 불변 객체는 변경 불가능하기 때문에 중간에 예기치 않게 수정되는 것을 방지할 수 있다.

### 리터럴로 생성한 String 객체와 생성자로 생성한 String 객체는 어떤 차이가 있나요?

| 구분            | `"abc"` (리터럴)                          | `new String("abc")` (생성자)       |
|---------------|----------------------------------------|---------------------------------|
| 생성 위치         | **String Intern Pool**(JVM이 관리하는 공유 풀) | **힙에 새 인스턴스**                   |
| 동일 내용 재사용     | **예**: 같은 리터럴은 같은 객체 참조                | **아니오**: 매번 새 객체(리터럴도 따로 풀에 존재) |
| `==` 비교       | 같은 리터럴이라면 `true` 가능                    | 보통 `false` (다른 객체)              |
| `equals` 비교   | 내용 같으면 `true`                          | 내용 같으면 `true`                   |
| `intern()` 호출 | 그대로 자기 자신 반환                           | 풀에 등록된 동일 값 참조를 반환              |

- 또한 생성자로 생성된 문자열도 `intern()` 메서드를 사용하면 Heap 영역에 저장된 String 객체를 String Pool에 저장할 수 있다.
- 이처럼 개발자는 해당 문자열이 리터럴이 넘어온건지, 생성자로 넘어온건지 알 수 없기 때문에 항상 equals() 메서드로 동등성 비교를 해야한다.

## 발화

String 객체는 기본적으로 final로 선언된 불변 객체입니다.

String 객체를 불변으로 설계함으로써 String Intern Pool로 관리하여 동일한 문자열을 하나의 객체로 공유하여 메모리 효율성을 높일 수 있고,
값이 변하지 않기 때문에 멀티스레드 환경에서 스레드 안전하고,
보안적인 측면에서도 긍정적인 측면이 있습니다.

또한 리터럴로 생성한 객체와 생성자로 생성한 객체는 본질적으로 다릅니다.
리터럴로 생성한 객체는 JVM이 관리하는 String Intern Pool(문자열 풀)에 저장되어 같은 객체를 참조하는 반면, new 연산자로 생성된 객체는 힙에 저장되어 생성 시마다 다른 객체를 만듭니다.
또한 리터럴 객체는 동일성과 동등성을 모두 충족하는 반면, 생성자 객체는 동등성만 만족하기 때문에 이를 사용하는 개발자 입장에선 어떤 객체로 넘어온지 알 수 없기 때문에 항상 equals로 비교를 해야합니다.


