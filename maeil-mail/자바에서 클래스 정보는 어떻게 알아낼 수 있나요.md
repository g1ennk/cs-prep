# 자바에서 클래스 정보는 어떻게 알아낼 수 있나요

## 요약

### 매일메일

- 자바에서 클래스 정보를 가져오기 위해서 `Reflection API`를 사용할 수 있다.
- 대표적 클래스
    - Class 클래스
    - Method 클래스
    - Field 클래스
- Reflection API 단점은?
    - 복잡한 코드
    - 캡슐화 약화로 인한 강결합
    - 성능 저하 가능성

### LLM

1. 정의
    - 자바에서 클래스 정보를 알아내는 방법은 `Class` 객체를 통해 리플랙션(Reflection) API를 사용하는 것이다.

2. 클래스 정보를 얻는 세 가지 방법

| 방법                          | 코드 예시                                                            | 설명                                                          |
|-----------------------------|------------------------------------------------------------------|-------------------------------------------------------------|
| **1️⃣ `Class.forName()`**   | `Class<?> clazz = Class.forName("com.example.User");`            | 문자열로 클래스 이름을 전달하여 `Class` 객체 획득<br>→ **런타임 시점에 동적으로 로드 가능** |
| **2️⃣ `.class` 리터럴 사용**     | `Class<User> clazz = User.class;`                                | 컴파일 타임에 타입이 명확할 때 사용<br>→ 가장 단순하고 빠름                        |
| **3️⃣ `getClass()` 메서드 사용** | `User user = new User();`<br>`Class<?> clazz = user.getClass();` | 이미 생성된 객체로부터 클래스 정보 획득                                      |

3. 리플랙션 API로 얻을 수 있는 정보

| 종류     | 메서드                               | 설명                    |
|--------|-----------------------------------|-----------------------|
| 클래스 이름 | `clazz.getName()`                 | 전체 클래스명 (패키지 포함)      |
| 필드     | `clazz.getDeclaredFields()`       | 모든 필드 목록 (private 포함) |
| 메서드    | `clazz.getDeclaredMethods()`      | 모든 메서드 목록             |
| 생성자    | `clazz.getDeclaredConstructors()` | 생성자 목록                |
| 슈퍼클래스  | `clazz.getSuperclass()`           | 상속받은 부모 클래스           |
| 인터페이스  | `clazz.getInterfaces()`           | 구현한 인터페이스 목록          |
| 어노테이션  | `clazz.getAnnotations()`          | 적용된 어노테이션 목록          |

4. 활용 예시

| 활용 분야                       | 설명                                              |
|-----------------------------|-------------------------------------------------|
| **DI(의존성 주입)**              | Spring의 `@Autowired`나 Bean 주입은 리플렉션으로 필드를 찾아 주입 |
| **ORM (예: JPA, Hibernate)** | Entity 클래스의 필드 메타데이터를 리플렉션으로 분석하여 SQL 매핑        |
| **JSON 직렬화/역직렬화**           | Jackson, Gson 등은 객체의 필드 정보를 리플렉션으로 접근           |
| **테스트 프레임워크**               | JUnit이 `@Test`가 붙은 메서드를 리플렉션으로 찾아 실행            |

5. 주의할 점

| 항목         | 설명                                                  |
|------------|-----------------------------------------------------|
| **성능 저하**  | 리플렉션은 런타임에서 동적으로 동작하므로 일반 호출보다 느림                   |
| **캡슐화 위반** | private 필드나 메서드에 접근 가능 → 설계 의도 깨질 수 있음              |
| **보안 위험**  | 내부 구조 노출 가능, 권한 체크 필요 (`setAccessible(true)` 남용 금지) |

## 발화

자바에서는 클래스 정보를 Class 객체를 통해 얻을 수 있으며,
이를 기반으로 리플렉션(Reflection) API를 사용해 클래스의 필드, 메서드, 생성자 등의 정보를 런타임에 조회하거나 조작할 수 있습니다.

`Class.forName()`이나 `.class`, `getClass()` 같은 방법으로 Class 객체를 얻은 뒤,
getDeclaredMethods()나 getDeclaredFields()로 세부 정보를 확인할 수 있습니다.

이러한 리플렉션 기능은 Spring의 의존성 주입, JPA의 Entity 매핑, 테스트 실행 등에서 내부적으로 많이 사용되지만,
성능 저하나 캡슐화 위반 위험이 있어 일반 코드에서는 신중히 사용하는 것이 좋습니다.
